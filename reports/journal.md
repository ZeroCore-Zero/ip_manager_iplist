# 开发日记

## 最初的设想

> [!NOTE]
> 这部分设想的代码部分忘记开git了所以没有力（悲

首先看到不限语言直接上python（人生苦短我用py）

最开始感觉数据量可能会很大，不能用之前习惯的json文件大法，可能需要调用数据库。但是MySQL过于臃肿，需要部署服务端比较麻烦，python调用还需要安装额外依赖，所以还是使用sqlite3（内置库不用白不用）

看过一遍文档后感觉接口实现不是特别重要，所以直接先写调用API的部分，打算之后再想办法写接口。于是开始翻出python官方的sqlite3库参考开始手搓SQL。（发现还剩个`init.sql`没删，交到git里留个档）

*搓了一半之后去写自己的东西了，中间断了两天没动过这个项目*

## 推翻重来

2024.09.10
花一晚上时间写了个vue+flask+sqlite的爬虫，翻回来看这个项目的代码，感觉用官方sqlite3手搓sql还是高估自己了，又因为http服务端我又只会flask（应该不会有人想用http.server吧），所以决定使用flask_sqlalchemy与数据库通信。

这次先把接口写好，反正只是读取数据库然后组织成json后返回。注意到题目返回中的`dhcp_expiry`字段只有一个，但ipv4和v6都有各自的过期时间。在群里询问之后发现是题目的问题。兼容性考虑不修改数据库结构里，在接口函数里手动只使用ipv4的过期时间就行。

2024.09.11
思考如何把v4 v6 arp信息组合起来，起初想用duid作为标识，但发现v4 v6生成的duid不同，最后使用主机名组合v4 v6，然后遍历arp更新在线时间。

2024.09.16
鸽了老长时间重新回来写（顽皮），发现主机名可能有重复（如*）没有考虑到。再次去看生成数据的代码，发现mac+ipv4，iaid+ipv6组合出现，所以直接用mac和iaid做索引代替主机名（之前为啥没想到嘞）。

欸不对，dhcpv6不给mac···，还是换回主机名，但是判断是否已存在数据，如果存在的话插入。

**初版完成**

2024.09.17
着手实现登录状态检测：在服务器上测试了下，发现直接向10.3.8.211发送登录数据和网关服务器上的nginx部署没有交叉，询问后确认可以代登录和自己单独登录，两种方式都要能够检测。直接想到了能够通过抓取10.3.8.211返回的http包来检测。

*运维面试之后*

研究完页面后研究认证页面，不抓包了，上传统技艺爬虫：直接爬取认证页面，通过页面内容判断是否已登录。但遇到问题：如何模拟nginx改写tcp报头的ip为客户端ip

2024.09.18
使用socket透明代理，改写源ip为需要判断的ip发送到认证服务器，通过解析返回的html文本判断是否已登录。

2024.09.19
调试完成，最后还剩个ws

2024.09.24
ws写好辣，写自述提交